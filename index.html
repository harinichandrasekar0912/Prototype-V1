<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Architectural Assistant Prototype V1</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .section {
      margin-bottom: 30px;
    }
    textarea, input {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
    }
    svg {
      border: 1px solid #ccc;
      margin-top: 20px;
      background-color: #f9f9f9;
      max-width: 100%;
      height: auto;
      display: block;
    }
    button {
      padding: 10px 15px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Prototype V1 – Interactive Architectural Assistant</h1>

  <!-- STEP 1: SITE + CONTEXT -->
  <div class="section" id="step1">
    <h2>Step 1: Site + Context Input</h2>

    <label>Site Boundary Coordinates (e.g., (0,0,0);(21,0,0);(21,25,0);(0,25,0))</label>
    <textarea id="siteCoords"></textarea>

    <label>Tree Data – (x,y,0,radius,height); separate multiple trees with semicolon</label>
    <textarea id="treeData"></textarea>

    <label>Context Buildings – Enter building footprints like:<br>
    ((x1,y1,z1);(x2,y2,z2);(x3,y3,z3));((x4,y4,z4);(x5,y5,z5);(x6,y6,z6))</label>
    <textarea id="contextData"></textarea>

    <label>Road Side and Width – Enter boundary edge (x1,y1,0);(x2,y2,0) and road width</label>
    <textarea id="roadEdge"></textarea>
    <input id="roadWidth" placeholder="Enter road width (e.g., 6)" />

    <button onclick="renderStep1()">Render Step 1</button>
    <button onclick="goToStep2()">Proceed to Step 2</button>

    <svg id="canvas" preserveAspectRatio="xMidYMid meet" width="100%" height="auto" style="border:1px dashed #ccc;"></svg>
  </div>

  <script>
    function parseCoords(str) {
      return str.split(";").map(s => s.replace(/[()]/g, "").split(",").map(Number));
    }

    function renderStep1() {
      const svg = document.getElementById("canvas");
      svg.innerHTML = "";

      const scale = 10;
      const siteRaw = document.getElementById("siteCoords").value.trim();
      const sitePoints = siteRaw.split(";").map(pt => {
        const [x, y] = pt.replace(/[()]/g, "").split(",").map(Number);
        return { x, y };
      });

      if (sitePoints.length < 3) return;

      const allX = sitePoints.map(p => p.x);
      const allY = sitePoints.map(p => p.y);
      const minX = Math.min(...allX);
      const maxX = Math.max(...allX);
      const minY = Math.min(...allY);
      const maxY = Math.max(...allY);

      const padding = 50;
      const bboxWidth = (maxX - minX) * scale + 2 * padding;
      const bboxHeight = (maxY - minY) * scale + 2 * padding;
      const offsetX = padding - minX * scale;
      const offsetY = padding + maxY * scale; // invert Y

      svg.setAttribute("viewBox", `0 0 ${bboxWidth} ${bboxHeight}`);
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "auto");
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      // GRID BACKGROUND
      const gridSpacing = scale;
      for (let x = 0; x < bboxWidth; x += gridSpacing) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x);
        line.setAttribute("y1", 0);
        line.setAttribute("x2", x);
        line.setAttribute("y2", bboxHeight);
        line.setAttribute("stroke", "#eee");
        line.setAttribute("stroke-width", 0.5);
        svg.appendChild(line);
      }
      for (let y = 0; y < bboxHeight; y += gridSpacing) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", 0);
        line.setAttribute("y1", y);
        line.setAttribute("x2", bboxWidth);
        line.setAttribute("y2", y);
        line.setAttribute("stroke", "#eee");
        line.setAttribute("stroke-width", 0.5);
        svg.appendChild(line);
      }

      // SITE BOUNDARY (transparent fill, black stroke)
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointStr = sitePoints.map(p => `${p.x * scale + offsetX},${offsetY - p.y * scale}`).join(" ");
      polygon.setAttribute("points", pointStr);
      polygon.setAttribute("fill", "transparent");
      polygon.setAttribute("stroke", "black");
      polygon.setAttribute("stroke-width", 2);
      svg.appendChild(polygon);

      // TREES
      const trees = document.getElementById("treeData").value.trim();
      if (trees) {
        trees.split(";").forEach(t => {
          const [x, y, , r] = t.replace(/[()]/g, "").split(",").map(Number);
          const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          circle.setAttribute("cx", x * scale + offsetX);
          circle.setAttribute("cy", offsetY - y * scale);
          circle.setAttribute("r", r * scale);
          circle.setAttribute("fill", "green");
          circle.setAttribute("fill-opacity", "0.25");
          svg.appendChild(circle);
        });
      }

      // CONTEXT BUILDINGS (draw as rectangles)
      const buildingRaw = document.getElementById("contextData").value.trim();
      const buildings = buildingRaw.match(/\(\((.*?)\)\)/g);
      if (buildings) {
        buildings.forEach(group => {
          const vertexStr = group.replace(/\(|\)/g, "");
          const vertices = vertexStr.split(";").map(pt => {
            const [x, y] = pt.trim().split(",").map(Number);
            return { x, y };
          });

          if (vertices.length >= 2) {
            const minX = Math.min(...vertices.map(v => v.x));
            const minY = Math.min(...vertices.map(v => v.y));
            const maxX = Math.max(...vertices.map(v => v.x));
            const maxY = Math.max(...vertices.map(v => v.y));

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", minX * scale + offsetX);
            rect.setAttribute("y", offsetY - maxY * scale);
            rect.setAttribute("width", (maxX - minX) * scale);
            rect.setAttribute("height", (maxY - minY) * scale);
            rect.setAttribute("fill", "#bbb");
            rect.setAttribute("stroke", "#333");
            rect.setAttribute("stroke-width", 1);
            rect.setAttribute("opacity", 0.6);
            svg.appendChild(rect);
          }
        });
      }

      // ROAD LINE
      const roadEdge = document.getElementById("roadEdge").value.trim();
      const roadWidth = parseFloat(document.getElementById("roadWidth").value.trim());
      if (roadEdge && !isNaN(roadWidth)) {
        const [p1, p2] = roadEdge.split(";").map(p => {
          const [x, y] = p.replace(/[()]/g, "").split(",").map(Number);
          return { x, y };
        });

        const road = document.createElementNS("http://www.w3.org/2000/svg", "line");
        road.setAttribute("x1", p1.x * scale + offsetX);
        road.setAttribute("y1", offsetY - p1.y * scale);
        road.setAttribute("x2", p2.x * scale + offsetX);
        road.setAttribute("y2", offsetY - p2.y * scale);
        road.setAttribute("stroke", "#666");
        road.setAttribute("stroke-width", roadWidth * scale);
        road.setAttribute("opacity", 0.5);
        svg.appendChild(road);
      }
    }

    function goToStep2() {
      document.getElementById("step1").style.display = "none";
      document.getElementById("step2").style.display = "block";
    }
  </script>

<!-- STEP 2: GROUND ZONING -->
<div class="section" id="step2" style="display:none;">
  <h2>Step 2: Ground Zoning & Footprint Analysis</h2>

  <p><strong>Setback Info:</strong> Front = 3m, Rear & Sides = 1.5m. Frontage side is determined based on road location.</p>

  <label>Preserved Trees – (x,y,0,radius,height); separate with semicolon</label>
  <textarea id="preservedTrees"></textarea>

  <label>Predominant Wind Direction – Enter two points (start to end): (x1,y1,z1);(x2,y2,z2)</label>
  <textarea id="windDirection"></textarea>

  <label>Noise Sources – ((x,y,z,radius);(...))</label>
  <textarea id="noiseSources"></textarea>

  <label>View Directions – ((x1,y1,z1);(x2,y2,z2));((x3,y3,z3);(x4,y4,z4)) etc.</label>
  <textarea id="viewDirections"></textarea>

  <label>Privacy Concern Sources – ((x,y,z,radius);(...))</label>
  <textarea id="privacySources"></textarea>

  <button onclick="renderStep2()">Render Step 2</button>
  <button onclick="goToStep3()">Proceed to Step 3</button>

  <svg id="zoningCanvas" preserveAspectRatio="xMidYMid meet" width="100%" height="auto" style="border:1px dashed #ccc; background-color:#f9f9f9;">
    <defs>
      <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L6,3 L0,6 Z" fill="red" />
      </marker>
      <marker id="windArrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L6,3 L0,6 Z" fill="blue" />
      </marker>
      <marker id="viewArrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L6,3 L0,6 Z" fill="pink" />
      </marker>
    </defs>
  </svg>
</div>


<style>
  .section textarea,
  .section input {
    width: 100%;
    padding: 8px;
    margin: 5px 0 15px 0;
    font-family: monospace;
  }
  .section label {
    font-weight: bold;
    margin-top: 10px;
    display: block;
  }
</style>


    <!-- STEP 3: AREA STATEMENT -->
  <div class="section" id="step3" style="display:none;">
    <h2>Step 3: Area Statement</h2>

    <button onclick="generateAreaStatement()">Generate Area Statement</button>

    <div id="areaStatementOutput" style="margin-top: 15px; border: 1px solid #ddd; padding: 10px; background-color: #f9f9f9;">
      <strong>Area Statement will appear here.</strong>
    </div>

    <button onclick="goToStep4()">Proceed to Step 4</button>
  </div>

  <!-- STEP 4: BUBBLE DIAGRAM -->
  <div class="section" id="step4" style="display:none;">
    <h2>Step 4: Bubble Diagram</h2>
    <p>[UI and logic for Step 4 will go here]</p>
    <button onclick="goToStep5()">Proceed to Step 5</button>
  </div>

  <!-- STEP 5: FINAL PLAN -->
  <div class="section" id="step5" style="display:none;">
    <h2>Step 5: Final Plan</h2>
    <p>[UI and logic for Step 5 will go here]</p>
  </div>

  <script>
function renderStep2() {
  try {
    generateZoning();
  } catch (err) {
    console.error("Error in generateZoning():", err);
    alert("An error occurred while rendering Step 2. Check the console for details.");
  }
}

function parseCoordPair(str) {
  return str.replace(/[()]/g, '').split(',').map(Number);
}

function parseMultiPairs(str) {
  const groups = str.match(/\(\(.*?\)\)/g);
  return groups ? groups.map(group => {
    const pts = group.replace(/\(|\)/g, '').split(';');
    return pts.map(pt => pt.split(',').map(Number));
  }) : [];
}

function generateZoning() {
  const svg = document.getElementById("zoningCanvas");
  svg.innerHTML = "";

  const scale = 10;
  const margin = 50;

  const parseCoordPair = str => str.replace(/[()]/g, "").split(",").map(Number);
  const parseMultiPairs = str => {
    return (str.match(/\(\((.*?)\)\)/g) || []).map(group =>
      group.replace(/[()]/g, "").split(";").map(pair => pair.split(",").map(Number))
    );
  };

  // --- Get site boundary
  const siteRaw = document.getElementById("siteCoords").value.trim();
  const sitePts = siteRaw.split(";").map(pt => {
    const [x, y] = pt.replace(/[()]/g, '').split(",").map(Number);
    return { x, y };
  });

  const allX = sitePts.map(p => p.x);
  const allY = sitePts.map(p => p.y);
  const minX = Math.min(...allX), maxX = Math.max(...allX);
  const minY = Math.min(...allY), maxY = Math.max(...allY);

  const bboxWidth = (maxX - minX) * scale + 2 * margin;
  const bboxHeight = (maxY - minY) * scale + 2 * margin;
  const offsetX = margin - minX * scale;
  const offsetY = margin + maxY * scale;

  svg.setAttribute("viewBox", `0 0 ${bboxWidth} ${bboxHeight}`);
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "auto");
  svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

  // --- Grid
  for (let x = 0; x < bboxWidth; x += scale) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x); line.setAttribute("y1", 0);
    line.setAttribute("x2", x); line.setAttribute("y2", bboxHeight);
    line.setAttribute("stroke", "#eee"); line.setAttribute("stroke-width", 0.5);
    svg.appendChild(line);
  }
  for (let y = 0; y < bboxHeight; y += scale) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", 0); line.setAttribute("y1", y);
    line.setAttribute("x2", bboxWidth); line.setAttribute("y2", y);
    line.setAttribute("stroke", "#eee"); line.setAttribute("stroke-width", 0.5);
    svg.appendChild(line);
  }

  // --- Site boundary
  const sitePolygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  sitePolygon.setAttribute("points", sitePts.map(p => `${p.x * scale + offsetX},${offsetY - p.y * scale}`).join(" "));
  sitePolygon.setAttribute("fill", "none");
  sitePolygon.setAttribute("stroke", "black");
  sitePolygon.setAttribute("stroke-width", 2);
  svg.appendChild(sitePolygon);

    // --- Frontage detection from roadEdge
  const roadCoords = document.getElementById("roadEdge").value.trim().split(";").map(parseCoordPair);
  const isFrontEdge = (p1, p2, edge1, edge2) => {
    const same = (a, b) => Math.abs(a[0] - b[0]) < 0.01 && Math.abs(a[1] - b[1]) < 0.01;
    return (same(p1, edge1) && same(p2, edge2)) || (same(p1, edge2) && same(p2, edge1));
  };

  // --- Setbacks
  for (let i = 0; i < sitePts.length; i++) {
    const curr = sitePts[i];
    const next = sitePts[(i + 1) % sitePts.length];
    const dx = next.x - curr.x, dy = next.y - curr.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / length, uy = dy / length;

    const isFront = isFrontEdge([curr.x, curr.y], [next.x, next.y], roadCoords[0], roadCoords[1]);
    const setback = isFront ? 3 : 1.5;

    const offsetX1 = curr.x - uy * setback;
    const offsetY1 = curr.y + ux * setback;
    const offsetX2 = next.x - uy * setback;
    const offsetY2 = next.y + ux * setback;

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", offsetX1 * scale + offsetX);
    line.setAttribute("y1", offsetY - offsetY1 * scale);
    line.setAttribute("x2", offsetX2 * scale + offsetX);
    line.setAttribute("y2", offsetY - offsetY2 * scale);
    line.setAttribute("stroke", "red");
    line.setAttribute("stroke-width", 1);
    line.setAttribute("stroke-dasharray", "5,5");
    svg.appendChild(line);
  }

  // --- Road polygon
  const roadWidth = parseFloat(document.getElementById("roadWidth").value);
  if (roadCoords.length === 2 && !isNaN(roadWidth)) {
    const [[x1, y1], [x2, y2]] = roadCoords;
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const nx = -dy / len, ny = dx / len;
    const w = roadWidth / 2;

    const polyPts = [
      [x1 + nx * w, y1 + ny * w],
      [x2 + nx * w, y2 + ny * w],
      [x2 - nx * w, y2 - ny * w],
      [x1 - nx * w, y1 - ny * w]
    ];
    const road = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    road.setAttribute("points", polyPts.map(([x, y]) => `${x * scale + offsetX},${offsetY - y * scale}`).join(" "));
    road.setAttribute("fill", "grey");
    road.setAttribute("fill-opacity", 0.3);
    svg.appendChild(road);
  }

  // --- Preserved Trees
  const trees = document.getElementById("preservedTrees").value.trim().split(";").filter(Boolean);
  trees.forEach(t => {
    const [x, y, , r] = t.replace(/[()]/g, "").split(",").map(Number);
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", x * scale + offsetX);
    circle.setAttribute("cy", offsetY - y * scale);
    circle.setAttribute("r", r * scale);
    circle.setAttribute("fill", "green");
    circle.setAttribute("fill-opacity", 0.25);
    circle.setAttribute("stroke", "green");
    svg.appendChild(circle);
  });

  // --- Contextual Buildings
  const contextRaw = document.getElementById("contextData").value.trim();
  const buildings = parseMultiPairs(contextRaw);
  buildings.forEach(building => {
    const xs = building.map(p => p[0]);
    const ys = building.map(p => p[1]);
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", Math.min(...xs) * scale + offsetX);
    rect.setAttribute("y", offsetY - Math.max(...ys) * scale);
    rect.setAttribute("width", (Math.max(...xs) - Math.min(...xs)) * scale);
    rect.setAttribute("height", (Math.max(...ys) - Math.min(...ys)) * scale);
    rect.setAttribute("fill", "#bbb");
    rect.setAttribute("opacity", 0.6);
    svg.appendChild(rect);
  });

    // --- Entry/Exit Arrows
  const [rx1, ry1] = roadCoords[0];
  const [rx2, ry2] = roadCoords[1];
  const roadDx = rx2 - rx1;
  const roadDy = ry2 - ry1;
  const roadLen = Math.sqrt(roadDx * roadDx + roadDy * roadDy);
  const normX = -roadDy / roadLen;
  const normY = roadDx / roadLen;

  const midX = (rx1 + rx2) / 2;
  const midY = (ry1 + ry2) / 2;

  const entryPos = [midX - roadDx * 0.1, midY - roadDy * 0.1];
  const exitPos  = [midX + roadDx * 0.1, midY + roadDy * 0.1];

  [[entryPos, 1], [exitPos, -1]].forEach(([pos, dir]) => {
    const [cx, cy] = pos;
    const x1 = cx;
    const y1 = cy;
    const x2 = cx + normX * 1 * dir;
    const y2 = cy + normY * 1 * dir;

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x1 * scale + offsetX);
    line.setAttribute("y1", offsetY - y1 * scale);
    line.setAttribute("x2", x2 * scale + offsetX);
    line.setAttribute("y2", offsetY - y2 * scale);
    line.setAttribute("stroke", "red");
    line.setAttribute("stroke-width", "2");
    line.setAttribute("marker-end", "url(#arrow)");
    svg.appendChild(line);
  });

  // Define red arrow marker
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  const arrowMarker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  arrowMarker.setAttribute("id", "arrow");
  arrowMarker.setAttribute("markerWidth", "6");
  arrowMarker.setAttribute("markerHeight", "6");
  arrowMarker.setAttribute("refX", "5");
  arrowMarker.setAttribute("refY", "3");
  arrowMarker.setAttribute("orient", "auto");
  arrowMarker.setAttribute("markerUnits", "strokeWidth");

  const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  arrowPath.setAttribute("d", "M0,0 L6,3 L0,6 Z");
  arrowPath.setAttribute("fill", "red");
  arrowMarker.appendChild(arrowPath);
  defs.appendChild(arrowMarker);
  svg.appendChild(defs);

  // --- Wind Direction
  const windRaw = document.getElementById("windDirection").value.trim();
  if (windRaw.includes(";")) {
    const [start, end] = windRaw.split(";").map(p => p.replace(/[()]/g, "").split(",").map(Number));
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", start[0] * scale + offsetX);
    line.setAttribute("y1", offsetY - start[1] * scale);
    line.setAttribute("x2", end[0] * scale + offsetX);
    line.setAttribute("y2", offsetY - end[1] * scale);
    line.setAttribute("stroke", "blue");
    line.setAttribute("stroke-dasharray", "5,4");
    line.setAttribute("stroke-width", 2);
    line.setAttribute("marker-end", "url(#windArrow)");
    svg.appendChild(line);

    const windArrow = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    windArrow.setAttribute("id", "windArrow");
    windArrow.setAttribute("markerWidth", "6");
    windArrow.setAttribute("markerHeight", "6");
    windArrow.setAttribute("refX", "5");
    windArrow.setAttribute("refY", "3");
    windArrow.setAttribute("orient", "auto");
    windArrow.setAttribute("markerUnits", "strokeWidth");

    const windPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    windPath.setAttribute("d", "M0,0 L6,3 L0,6 Z");
    windPath.setAttribute("fill", "blue");
    windArrow.appendChild(windPath);
    defs.appendChild(windArrow);
  }

  // --- Noise Sources
  const noiseRaw = document.getElementById("noiseSources").value.trim();
  if (noiseRaw) {
    const points = noiseRaw.match(/\((.*?)\)/g) || [];
    points.forEach(p => {
      const [x, y, , radius] = p.replace(/[()]/g, "").split(",").map(Number);
      for (let r = 1; r <= radius; r++) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x * scale + offsetX);
        circle.setAttribute("cy", offsetY - y * scale);
        circle.setAttribute("r", r * scale);
        circle.setAttribute("stroke", "orange");
        circle.setAttribute("stroke-width", 0.6);
        circle.setAttribute("fill", "none");
        svg.appendChild(circle);
      }
      const centerDot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      centerDot.setAttribute("cx", x * scale + offsetX);
      centerDot.setAttribute("cy", offsetY - y * scale);
      centerDot.setAttribute("r", 1.5);
      centerDot.setAttribute("fill", "orange");
      svg.appendChild(centerDot);
    });
  }

  // --- Privacy Sources
  const privacyRaw = document.getElementById("privacySources").value.trim();
  if (privacyRaw) {
    const points = privacyRaw.match(/\((.*?)\)/g) || [];
    points.forEach(p => {
      const [x, y, , radius] = p.replace(/[()]/g, "").split(",").map(Number);
      for (let r = 1; r <= radius; r++) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x * scale + offsetX);
        circle.setAttribute("cy", offsetY - y * scale);
        circle.setAttribute("r", r * scale);
        circle.setAttribute("stroke", "purple");
        circle.setAttribute("stroke-width", 0.6);
        circle.setAttribute("fill", "none");
        svg.appendChild(circle);
      }
      const centerDot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      centerDot.setAttribute("cx", x * scale + offsetX);
      centerDot.setAttribute("cy", offsetY - y * scale);
      centerDot.setAttribute("r", 1.5);
      centerDot.setAttribute("fill", "purple");
      svg.appendChild(centerDot);
    });
  }

  // --- Views (pink arrows)
  const viewsRaw = document.getElementById("viewDirections").value.trim();
  if (viewsRaw) {
    const arrowPairs = viewsRaw.match(/\((.*?)\);?\((.*?)\)/g);
    if (arrowPairs && arrowPairs.length % 2 === 0) {
      for (let i = 0; i < arrowPairs.length; i += 2) {
        const [x1, y1] = arrowPairs[i].replace(/[()]/g, "").split(",").map(Number);
        const [x2, y2] = arrowPairs[i + 1].replace(/[()]/g, "").split(",").map(Number);
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1 * scale + offsetX);
        line.setAttribute("y1", offsetY - y1 * scale);
        line.setAttribute("x2", x2 * scale + offsetX);
        line.setAttribute("y2", offsetY - y2 * scale);
        line.setAttribute("stroke", "pink");
        line.setAttribute("stroke-dasharray", "4 2");
        line.setAttribute("stroke-width", 2);
        line.setAttribute("marker-end", "url(#viewArrow)");
        svg.appendChild(line);
      }
      const viewArrow = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      viewArrow.setAttribute("id", "viewArrow");
      viewArrow.setAttribute("markerWidth", "6");
      viewArrow.setAttribute("markerHeight", "6");
      viewArrow.setAttribute("refX", "5");
      viewArrow.setAttribute("refY", "3");
      viewArrow.setAttribute("orient", "auto");
      viewArrow.setAttribute("markerUnits", "strokeWidth");

      const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      arrowPath.setAttribute("d", "M0,0 L6,3 L0,6 Z");
      arrowPath.setAttribute("fill", "pink");
      viewArrow.appendChild(arrowPath);
      defs.appendChild(viewArrow);
    }
  }
}

function generateAreaStatement() {
      const siteWidth = parseFloat(document.getElementById("siteWidth").value);
      const siteDepth = parseFloat(document.getElementById("siteDepth").value);
      const setbackFront = parseFloat(document.getElementById("setbackFront").value);
      const setbackRear = parseFloat(document.getElementById("setbackRear").value);
      const setbackSide = parseFloat(document.getElementById("setbackSide").value);

      const siteArea = siteWidth * siteDepth;
      const buildableWidth = siteWidth - (2 * setbackSide);
      const buildableDepth = siteDepth - (setbackFront + setbackRear);
      const buildableArea = buildableWidth * buildableDepth;

      const FSI = 1.5;
      const builtUpArea = siteArea * FSI;

      const outputHTML = `
        <h3>Area Statement</h3>
        <ul>
          <li><strong>Site Area:</strong> ${siteArea.toFixed(2)} sq.m</li>
          <li><strong>Buildable Area (after setbacks):</strong> ${buildableArea.toFixed(2)} sq.m</li>
          <li><strong>Assumed FSI:</strong> ${FSI}</li>
          <li><strong>Permissible Built-up Area:</strong> ${builtUpArea.toFixed(2)} sq.m</li>
          <li><strong>Setbacks Applied:</strong> Front = ${setbackFront} m, Rear = ${setbackRear} m, Side = ${setbackSide} m (both sides)</li>
        </ul>
      `;
      document.getElementById("areaStatementOutput").innerHTML = outputHTML;
    }

    function goToStep3() {
      document.getElementById("step2").style.display = "none";
      document.getElementById("step3").style.display = "block";
    }

    function goToStep4() {
      document.getElementById("step3").style.display = "none";
      document.getElementById("step4").style.display = "block";
    }

    function goToStep5() {
      document.getElementById("step4").style.display = "none";
      document.getElementById("step5").style.display = "block";
    }
  </script>
</body>
</html>
