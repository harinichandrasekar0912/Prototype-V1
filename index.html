<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Architectural Assistant Prototype V1</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .section {
      margin-bottom: 30px;
    }
    textarea, input {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
    }
    svg {
      border: 1px solid #ccc;
      margin-top: 20px;
      background-color: #f9f9f9;
      max-width: 100%;
      height: auto;
      display: block;
    }
    button {
      padding: 10px 15px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Prototype V1 – Interactive Architectural Assistant</h1>

  <!-- STEP 1: SITE + CONTEXT -->
  <div class="section" id="step1">
    <h2>Step 1: Site + Context Input</h2>

    <label>Site Boundary Coordinates (e.g., (0,0,0);(21,0,0);(21,25,0);(0,25,0))</label>
    <textarea id="siteCoords"></textarea>

    <label>Tree Data – (x,y,0,radius,height); separate multiple trees with semicolon</label>
    <textarea id="treeData"></textarea>

    <label>Context Buildings – Enter building footprints like:<br>
    ((x1,y1,z1);(x2,y2,z2);(x3,y3,z3));((x4,y4,z4);(x5,y5,z5);(x6,y6,z6))</label>
    <textarea id="contextData"></textarea>

    <label>Road Side and Width – Enter boundary edge (x1,y1,0);(x2,y2,0) and road width</label>
    <textarea id="roadEdge"></textarea>
    <input id="roadWidth" placeholder="Enter road width (e.g., 6)" />

    <button onclick="renderStep1()">Render Step 1</button>
    <button onclick="goToStep2()">Proceed to Step 2</button>

    <svg id="canvas" preserveAspectRatio="xMidYMid meet" width="100%" height="auto" style="border:1px dashed #ccc;"></svg>
  </div>

  <script>
    function parseCoords(str) {
      return str.split(";").map(s => s.replace(/[()]/g, "").split(",").map(Number));
    }

    function renderStep1() {
      const svg = document.getElementById("canvas");
      svg.innerHTML = "";

      const scale = 10;
      const siteRaw = document.getElementById("siteCoords").value.trim();
      const sitePoints = siteRaw.split(";").map(pt => {
        const [x, y] = pt.replace(/[()]/g, "").split(",").map(Number);
        return { x, y };
      });

      if (sitePoints.length < 3) return;

      const allX = sitePoints.map(p => p.x);
      const allY = sitePoints.map(p => p.y);
      const minX = Math.min(...allX);
      const maxX = Math.max(...allX);
      const minY = Math.min(...allY);
      const maxY = Math.max(...allY);

      const padding = 50;
      const bboxWidth = (maxX - minX) * scale + 2 * padding;
      const bboxHeight = (maxY - minY) * scale + 2 * padding;
      const offsetX = padding - minX * scale;
      const offsetY = padding + maxY * scale; // invert Y

      svg.setAttribute("viewBox", `0 0 ${bboxWidth} ${bboxHeight}`);
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "auto");
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      // GRID BACKGROUND
      const gridSpacing = scale;
      for (let x = 0; x < bboxWidth; x += gridSpacing) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x);
        line.setAttribute("y1", 0);
        line.setAttribute("x2", x);
        line.setAttribute("y2", bboxHeight);
        line.setAttribute("stroke", "#eee");
        line.setAttribute("stroke-width", 0.5);
        svg.appendChild(line);
      }
      for (let y = 0; y < bboxHeight; y += gridSpacing) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", 0);
        line.setAttribute("y1", y);
        line.setAttribute("x2", bboxWidth);
        line.setAttribute("y2", y);
        line.setAttribute("stroke", "#eee");
        line.setAttribute("stroke-width", 0.5);
        svg.appendChild(line);
      }

      // SITE BOUNDARY (transparent fill, black stroke)
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointStr = sitePoints.map(p => `${p.x * scale + offsetX},${offsetY - p.y * scale}`).join(" ");
      polygon.setAttribute("points", pointStr);
      polygon.setAttribute("fill", "transparent");
      polygon.setAttribute("stroke", "black");
      polygon.setAttribute("stroke-width", 2);
      svg.appendChild(polygon);

      // TREES
      const trees = document.getElementById("treeData").value.trim();
      if (trees) {
        trees.split(";").forEach(t => {
          const [x, y, , r] = t.replace(/[()]/g, "").split(",").map(Number);
          const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          circle.setAttribute("cx", x * scale + offsetX);
          circle.setAttribute("cy", offsetY - y * scale);
          circle.setAttribute("r", r * scale);
          circle.setAttribute("fill", "green");
          circle.setAttribute("fill-opacity", "0.25");
          svg.appendChild(circle);
        });
      }

      // CONTEXT BUILDINGS (draw as rectangles)
      const buildingRaw = document.getElementById("contextData").value.trim();
      const buildings = buildingRaw.match(/\(\((.*?)\)\)/g);
      if (buildings) {
        buildings.forEach(group => {
          const vertexStr = group.replace(/\(|\)/g, "");
          const vertices = vertexStr.split(";").map(pt => {
            const [x, y] = pt.trim().split(",").map(Number);
            return { x, y };
          });

          if (vertices.length >= 2) {
            const minX = Math.min(...vertices.map(v => v.x));
            const minY = Math.min(...vertices.map(v => v.y));
            const maxX = Math.max(...vertices.map(v => v.x));
            const maxY = Math.max(...vertices.map(v => v.y));

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", minX * scale + offsetX);
            rect.setAttribute("y", offsetY - maxY * scale);
            rect.setAttribute("width", (maxX - minX) * scale);
            rect.setAttribute("height", (maxY - minY) * scale);
            rect.setAttribute("fill", "#bbb");
            rect.setAttribute("stroke", "#333");
            rect.setAttribute("stroke-width", 1);
            rect.setAttribute("opacity", 0.6);
            svg.appendChild(rect);
          }
        });
      }

      // ROAD LINE
      const roadEdge = document.getElementById("roadEdge").value.trim();
      const roadWidth = parseFloat(document.getElementById("roadWidth").value.trim());
      if (roadEdge && !isNaN(roadWidth)) {
        const [p1, p2] = roadEdge.split(";").map(p => {
          const [x, y] = p.replace(/[()]/g, "").split(",").map(Number);
          return { x, y };
        });

        const road = document.createElementNS("http://www.w3.org/2000/svg", "line");
        road.setAttribute("x1", p1.x * scale + offsetX);
        road.setAttribute("y1", offsetY - p1.y * scale);
        road.setAttribute("x2", p2.x * scale + offsetX);
        road.setAttribute("y2", offsetY - p2.y * scale);
        road.setAttribute("stroke", "#666");
        road.setAttribute("stroke-width", roadWidth * scale);
        road.setAttribute("opacity", 0.5);
        svg.appendChild(road);
      }
    }

    function goToStep2() {
      document.getElementById("step1").style.display = "none";
      document.getElementById("step2").style.display = "block";
    }
  </script>

<!-- STEP 2: GROUND ZONING -->
<div class="section" id="step2" style="display:none;">
  <h2>Step 2: Ground Zoning & Footprint Analysis</h2>

  <!-- Instructions -->
  <p><strong>Setback Info:</strong> Front = 3m, Rear & Sides = 1.5m. Frontage side is determined based on road location.</p>

  <!-- Preserved Trees -->
  <label>Preserved Trees – (x,y,0,radius,height); separate with semicolon</label>
  <textarea id="preservedTrees"></textarea>

  <!-- Wind Direction Input -->
  <label>Predominant Wind Direction – Enter two points (start to end): (x1,y1,z1);(x2,y2,z2)</label>
  <textarea id="windDirection"></textarea>

  <!-- Noise Sources -->
  <label>Noise Sources – ((x,y,z,radius);(...)); multiple sources in this format</label>
  <textarea id="noiseSources"></textarea>

  <!-- Views -->
  <label>View Directions – ((x1,y1,z1);(x2,y2,z2));((x3,y3,z3);(x4,y4,z4)) etc.</label>
  <textarea id="viewDirections"></textarea>

  <!-- Privacy Sources -->
  <label>Privacy Concern Sources – ((x,y,z,radius);(...))</label>
  <textarea id="privacySources"></textarea>

  <button onclick="renderStep2()">Render Step 2</button>
  <button onclick="goToStep3()">Proceed to Step 3</button>

  <svg id="zoningCanvas" preserveAspectRatio="xMidYMid meet" width="100%" height="auto" style="border:1px dashed #ccc; background-color:#f9f9f9;"></svg>
</div>

<style>
  .section textarea,
  .section input {
    width: 100%;
    padding: 8px;
    margin: 5px 0 15px 0;
    font-family: monospace;
  }
  .section label {
    font-weight: bold;
    margin-top: 10px;
    display: block;
  }
</style>


    <!-- STEP 3: AREA STATEMENT -->
  <div class="section" id="step3" style="display:none;">
    <h2>Step 3: Area Statement</h2>

    <button onclick="generateAreaStatement()">Generate Area Statement</button>

    <div id="areaStatementOutput" style="margin-top: 15px; border: 1px solid #ddd; padding: 10px; background-color: #f9f9f9;">
      <strong>Area Statement will appear here.</strong>
    </div>

    <button onclick="goToStep4()">Proceed to Step 4</button>
  </div>

  <!-- STEP 4: BUBBLE DIAGRAM -->
  <div class="section" id="step4" style="display:none;">
    <h2>Step 4: Bubble Diagram</h2>
    <p>[UI and logic for Step 4 will go here]</p>
    <button onclick="goToStep5()">Proceed to Step 5</button>
  </div>

  <!-- STEP 5: FINAL PLAN -->
  <div class="section" id="step5" style="display:none;">
    <h2>Step 5: Final Plan</h2>
    <p>[UI and logic for Step 5 will go here]</p>
  </div>

  <script>
function renderStep2() {
  try {
    generateZoning();
  } catch (err) {
    console.error("Error in generateZoning():", err);
    alert("An error occurred while rendering Step 2. Check the console for details.");
  }
}

function parseCoordPair(str) {
  return str.replace(/[()]/g, '').split(',').map(Number);
}

function parseMultiPairs(str) {
  const groups = str.match(/\(\(.*?\)\)/g);
  return groups ? groups.map(group => {
    const pts = group.replace(/\(|\)/g, '').split(';');
    return pts.map(pt => pt.split(',').map(Number));
  }) : [];
}

function generateZoning() {
  const svg = document.getElementById("zoningDiagram");
  svg.innerHTML = "";
  const scale = 10;
  const margin = 50;

  // ------------------ Get site boundary ------------------
  const siteRaw = document.getElementById("siteCoords").value.trim();
  const sitePts = siteRaw.split(";").map(pt => {
    const [x, y] = pt.replace(/[()]/g, '').split(",").map(Number);
    return { x, y };
  });

  const allX = sitePts.map(p => p.x);
  const allY = sitePts.map(p => p.y);
  const minX = Math.min(...allX);
  const maxX = Math.max(...allX);
  const minY = Math.min(...allY);
  const maxY = Math.max(...allY);

  const bboxWidth = (maxX - minX) * scale + 2 * margin;
  const bboxHeight = (maxY - minY) * scale + 2 * margin;
  const offsetX = margin - minX * scale;
  const offsetY = margin + maxY * scale;

  svg.setAttribute("viewBox", `0 0 ${bboxWidth} ${bboxHeight}`);
  svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
  svg.setAttribute("width", "100%");
  svg.setAttribute("height", "auto");

  // ------------------ Grid ------------------
  for (let x = 0; x < bboxWidth; x += scale) {
    let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x); line.setAttribute("y1", 0);
    line.setAttribute("x2", x); line.setAttribute("y2", bboxHeight);
    line.setAttribute("stroke", "#eee"); line.setAttribute("stroke-width", 0.5);
    svg.appendChild(line);
  }
  for (let y = 0; y < bboxHeight; y += scale) {
    let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", 0); line.setAttribute("y1", y);
    line.setAttribute("x2", bboxWidth); line.setAttribute("y2", y);
    line.setAttribute("stroke", "#eee"); line.setAttribute("stroke-width", 0.5);
    svg.appendChild(line);
  }

  // ------------------ Site Boundary ------------------
  let poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  poly.setAttribute("points", sitePts.map(p => `${p.x * scale + offsetX},${offsetY - p.y * scale}`).join(" "));
  poly.setAttribute("fill", "none"); poly.setAttribute("stroke", "black");
  poly.setAttribute("stroke-width", 2);
  svg.appendChild(poly);

  // ------------------ Red Setback Lines (internal) ------------------
  const frontSetback = 3, otherSetback = 1.5;
  for (let i = 0; i < sitePts.length; i++) {
    const curr = sitePts[i];
    const next = sitePts[(i + 1) % sitePts.length];
    const dx = next.x - curr.x, dy = next.y - curr.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / length, uy = dy / length;

    // Assume front = road side
    const roadCoords = document.getElementById("roadEdge").value.trim().split(";").map(parseCoordPair);
    const frontMatch = (p1, p2) => (
      (Math.abs(p1[0] - curr.x) < 1e-2 && Math.abs(p1[1] - curr.y) < 1e-2 &&
       Math.abs(p2[0] - next.x) < 1e-2 && Math.abs(p2[1] - next.y) < 1e-2) ||
      (Math.abs(p2[0] - curr.x) < 1e-2 && Math.abs(p2[1] - curr.y) < 1e-2 &&
       Math.abs(p1[0] - next.x) < 1e-2 && Math.abs(p1[1] - next.y) < 1e-2)
    );
    const setback = roadCoords.length === 2 && frontMatch(roadCoords[0], roadCoords[1]) ? frontSetback : otherSetback;

    const insetX1 = curr.x - uy * setback;
    const insetY1 = curr.y + ux * setback;
    const insetX2 = next.x - uy * setback;
    const insetY2 = next.y + ux * setback;

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", insetX1 * scale + offsetX);
    line.setAttribute("y1", offsetY - insetY1 * scale);
    line.setAttribute("x2", insetX2 * scale + offsetX);
    line.setAttribute("y2", offsetY - insetY2 * scale);
    line.setAttribute("stroke", "red");
    line.setAttribute("stroke-width", 1);
    line.setAttribute("stroke-dasharray", "5,5");
    svg.appendChild(line);
  }

  // ------------------ Trees to preserve ------------------
  const trees = document.getElementById("preserveTrees").value.trim().split(";").filter(Boolean);
  trees.forEach(t => {
    const [x, y, , r] = t.replace(/[()]/g, "").split(",").map(Number);
    let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", x * scale + offsetX);
    circle.setAttribute("cy", offsetY - y * scale);
    circle.setAttribute("r", r * scale);
    circle.setAttribute("fill", "green");
    circle.setAttribute("fill-opacity", 0.25);
    circle.setAttribute("stroke", "green");
    svg.appendChild(circle);
  });

  // ------------------ Road ------------------
  const roadWidth = parseFloat(document.getElementById("roadWidth").value);
  if (roadCoords.length === 2 && !isNaN(roadWidth)) {
    const [[x1, y1], [x2, y2]] = roadCoords;
    const dx = x2 - x1, dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / length, uy = dy / length;
    const ox = -uy, oy = ux;
    const w = roadWidth / 2;

    const polyPts = [
      [x1 + ox * w, y1 + oy * w],
      [x2 + ox * w, y2 + oy * w],
      [x2 - ox * w, y2 - oy * w],
      [x1 - ox * w, y1 - oy * w]
    ];
    const road = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    road.setAttribute("points", polyPts.map(([x, y]) => `${x * scale + offsetX},${offsetY - y * scale}`).join(" "));
    road.setAttribute("fill", "grey"); road.setAttribute("fill-opacity", 0.3);
    svg.appendChild(road);
  }

  // ------------------ Context Buildings ------------------
  const buildingsRaw = document.getElementById("contextData").value.trim();
  parseMultiPairs(buildingsRaw).forEach(building => {
    const xs = building.map(p => p[0]), ys = building.map(p => p[1]);
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", Math.min(...xs) * scale + offsetX);
    rect.setAttribute("y", offsetY - Math.max(...ys) * scale);
    rect.setAttribute("width", (Math.max(...xs) - Math.min(...xs)) * scale);
    rect.setAttribute("height", (Math.max(...ys) - Math.min(...ys)) * scale);
    rect.setAttribute("fill", "lightgrey");
    rect.setAttribute("opacity", 0.6);
    svg.appendChild(rect);
  });

  // ------------------ Entry / Exit Arrows ------------------
  const entry = document.createElementNS("http://www.w3.org/2000/svg", "line");
  const exit = document.createElementNS("http://www.w3.org/2000/svg", "line");

  const [p1, p2] = roadCoords;
const [rx1, ry1] = p1;
const [rx2, ry2] = p2;

  const midX = (rx1 + rx2) / 2;
  const midY = (ry1 + ry2) / 2;
  const dx = rx2 - rx1, dy = ry2 - ry1;
  const length = Math.sqrt(dx * dx + dy * dy);
  const nx = -dy / length, ny = dx / length;  // normal

  const arrowSize = 5 * scale;
  const entryMid = [midX - dx * 0.1, midY - dy * 0.1];
  const exitMid = [midX + dx * 0.1, midY + dy * 0.1];

  [entry, exit].forEach((arrow, i) => {
    const [cx, cy] = i === 0 ? entryMid : exitMid;
    const endX = cx + nx * (i === 0 ? 1 : -1) * 0.8;
    const endY = cy + ny * (i === 0 ? 1 : -1) * 0.8;
    arrow.setAttribute("x1", cx * scale + offsetX);
    arrow.setAttribute("y1", offsetY - cy * scale);
    arrow.setAttribute("x2", endX * scale + offsetX);
    arrow.setAttribute("y2", offsetY - endY * scale);
    arrow.setAttribute("stroke", "red");
    arrow.setAttribute("stroke-width", 2);
    arrow.setAttribute("marker-end", "url(#arrow)");
    svg.appendChild(arrow);
  });

  // ... (continue with wind direction, noise, views, privacy using same logic as you’ve already implemented) ...
}

  // --- WIND DIRECTION (dotted blue arrow) ---
  const windRaw = document.getElementById("windDirection").value.trim();
  if (windRaw) {
    const [start, end] = windRaw.split(";").map(p => {
      const [x, y] = p.replace(/[()]/g, "").split(",").map(Number);
      return { x, y };
    });

    const wind = document.createElementNS("http://www.w3.org/2000/svg", "line");
    wind.setAttribute("x1", start.x * scale + offsetX);
    wind.setAttribute("y1", offsetY - start.y * scale);
    wind.setAttribute("x2", end.x * scale + offsetX);
    wind.setAttribute("y2", offsetY - end.y * scale);
    wind.setAttribute("stroke", "blue");
    wind.setAttribute("stroke-width", 2);
    wind.setAttribute("stroke-dasharray", "4 3");
    wind.setAttribute("marker-end", "url(#windArrow)");
    svg.appendChild(wind);

    const windArrow = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    windArrow.setAttribute("id", "windArrow");
    windArrow.setAttribute("markerWidth", "6");
    windArrow.setAttribute("markerHeight", "6");
    windArrow.setAttribute("refX", "5");
    windArrow.setAttribute("refY", "3");
    windArrow.setAttribute("orient", "auto");
    windArrow.setAttribute("markerUnits", "strokeWidth");

    const windPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    windPath.setAttribute("d", "M0,0 L6,3 L0,6 Z");
    windPath.setAttribute("fill", "blue");
    windArrow.appendChild(windPath);
    svg.querySelector("defs").appendChild(windArrow);
  }

  // --- NOISE SOURCES (orange concentric circles) ---
  const noiseRaw = document.getElementById("noiseSources").value.trim();
  if (noiseRaw) {
    const sources = noiseRaw.match(/\((.*?)\)/g);
    sources.forEach(src => {
      const [x, y, , rMax] = src.replace(/[()]/g, "").split(",").map(Number);
      for (let r = 1; r <= rMax; r++) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x * scale + offsetX);
        circle.setAttribute("cy", offsetY - y * scale);
        circle.setAttribute("r", r * scale);
        circle.setAttribute("fill", "none");
        circle.setAttribute("stroke", "orange");
        circle.setAttribute("stroke-width", "0.6");
        svg.appendChild(circle);
      }
      const center = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      center.setAttribute("cx", x * scale + offsetX);
      center.setAttribute("cy", offsetY - y * scale);
      center.setAttribute("r", 2);
      center.setAttribute("fill", "orange");
      svg.appendChild(center);
    });
  }

  // --- PRIVACY SOURCES (purple concentric circles) ---
  const privacyRaw = document.getElementById("privacySources").value.trim();
  if (privacyRaw) {
    const sources = privacyRaw.match(/\((.*?)\)/g);
    sources.forEach(src => {
      const [x, y, , rMax] = src.replace(/[()]/g, "").split(",").map(Number);
      for (let r = 1; r <= rMax; r++) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x * scale + offsetX);
        circle.setAttribute("cy", offsetY - y * scale);
        circle.setAttribute("r", r * scale);
        circle.setAttribute("fill", "none");
        circle.setAttribute("stroke", "purple");
        circle.setAttribute("stroke-width", "0.6");
        svg.appendChild(circle);
      }
      const center = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      center.setAttribute("cx", x * scale + offsetX);
      center.setAttribute("cy", offsetY - y * scale);
      center.setAttribute("r", 2);
      center.setAttribute("fill", "purple");
      svg.appendChild(center);
    });
  }

  // --- VIEW DIRECTIONS (dotted pink arrows) ---
  const viewsRaw = document.getElementById("viewDirections").value.trim();
  if (viewsRaw) {
    const arrows = viewsRaw.match(/\((.*?)\);?\((.*?)\)/g);
    for (let i = 0; i < arrows.length; i += 2) {
      const [x1, y1] = arrows[i].replace(/[()]/g, "").split(",").map(Number);
      const [x2, y2] = arrows[i + 1].replace(/[()]/g, "").split(",").map(Number);

      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "line");
      arrow.setAttribute("x1", x1 * scale + offsetX);
      arrow.setAttribute("y1", offsetY - y1 * scale);
      arrow.setAttribute("x2", x2 * scale + offsetX);
      arrow.setAttribute("y2", offsetY - y2 * scale);
      arrow.setAttribute("stroke", "pink");
      arrow.setAttribute("stroke-dasharray", "3 2");
      arrow.setAttribute("stroke-width", "2");
      arrow.setAttribute("marker-end", "url(#viewArrow)");
      svg.appendChild(arrow);
    }

    const viewArrow = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    viewArrow.setAttribute("id", "viewArrow");
    viewArrow.setAttribute("markerWidth", "6");
    viewArrow.setAttribute("markerHeight", "6");
    viewArrow.setAttribute("refX", "5");
    viewArrow.setAttribute("refY", "3");
    viewArrow.setAttribute("orient", "auto");
    viewArrow.setAttribute("markerUnits", "strokeWidth");

    const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    arrowPath.setAttribute("d", "M0,0 L6,3 L0,6 Z");
    arrowPath.setAttribute("fill", "pink");
    viewArrow.appendChild(arrowPath);
    svg.querySelector("defs").appendChild(viewArrow);
  }


function generateAreaStatement() {
      const siteWidth = parseFloat(document.getElementById("siteWidth").value);
      const siteDepth = parseFloat(document.getElementById("siteDepth").value);
      const setbackFront = parseFloat(document.getElementById("setbackFront").value);
      const setbackRear = parseFloat(document.getElementById("setbackRear").value);
      const setbackSide = parseFloat(document.getElementById("setbackSide").value);

      const siteArea = siteWidth * siteDepth;
      const buildableWidth = siteWidth - (2 * setbackSide);
      const buildableDepth = siteDepth - (setbackFront + setbackRear);
      const buildableArea = buildableWidth * buildableDepth;

      const FSI = 1.5;
      const builtUpArea = siteArea * FSI;

      const outputHTML = `
        <h3>Area Statement</h3>
        <ul>
          <li><strong>Site Area:</strong> ${siteArea.toFixed(2)} sq.m</li>
          <li><strong>Buildable Area (after setbacks):</strong> ${buildableArea.toFixed(2)} sq.m</li>
          <li><strong>Assumed FSI:</strong> ${FSI}</li>
          <li><strong>Permissible Built-up Area:</strong> ${builtUpArea.toFixed(2)} sq.m</li>
          <li><strong>Setbacks Applied:</strong> Front = ${setbackFront} m, Rear = ${setbackRear} m, Side = ${setbackSide} m (both sides)</li>
        </ul>
      `;
      document.getElementById("areaStatementOutput").innerHTML = outputHTML;
    }

    function goToStep3() {
      document.getElementById("step2").style.display = "none";
      document.getElementById("step3").style.display = "block";
    }

    function goToStep4() {
      document.getElementById("step3").style.display = "none";
      document.getElementById("step4").style.display = "block";
    }

    function goToStep5() {
      document.getElementById("step4").style.display = "none";
      document.getElementById("step5").style.display = "block";
    }
  </script>
</body>
</html>
